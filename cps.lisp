(defpackage #:pk/hwsim
  (:use #:cl)
  (:shadow #:eval))
(in-package #:pk/hwsim)
(defstruct record (descriptor) (fields))
(defun record-field (record i)
  (aref (record-fields record) i))
(defun record (descriptor &rest fields)
  (make-record :descriptor descriptor
               :fields (apply #'vector fields)))
(defun tag (x)
  (typecase x
    (cons 'cons)
    ((eql _) '_)
    (null 'null)
    (symbol 'symbol)
    (fixnum 'fixnum)
    (record 'record)
    (vector 'object)))

(defmacro id (x) `(if (ldb-test (byte 1 0) (aref ,x 0)) 'hashenv 'vecenv))
(defmacro parent (x) `(aref ,x 1))
(defmacro keyvec (x) `(aref ,x 2))
(defmacro value (x i) `(aref ,x (+ 3 ,i)))

(defun eq? (x y)
  (case (tag x)
    ((cons) (and (eq? (tag y) 'cons)
                 (eq? (car x) (car y))
                 (eq? (cdr x) (cdr y))))
    ((record)
     (and (eq? (tag y) 'record)
          (eq (record-descriptor x)
              (record-descriptor y))
          (every #'eq? (record-fields x) (record-fields y))))
    (t (eq x y))))

(defun eqhash (x)
  (case (tag x)
    ((cons) (logxor (eqhash (car x)) (eqhash (cdr x))))
    ((record)
     (logxor (eqhash (record-descriptor x))
             (reduce #'logxor (record-fields x) :key #'eqhash)))
    ((object) (aref x 0))
    (t (sxhash x))))

(defun vecenv (parent list)
  (let ((s (length list)))
    (make-array (+ 3 s)
                :fill-pointer (+ 3 s)
                :adjustable t
                :initial-contents
                (list* (ash (random (ash 1 31)) 1) parent
                       (make-array s :fill-pointer s
                                     :adjustable t
                                     :initial-contents (mapcar #'car list))
                       (mapcar #'cadr list)))))

(defun hashenv (parent list)
  (let ((table (make-hash-table :test #'eq? :hash-function #'eqhash)))
    (mapc (lambda (binding)
            (setf (gethash (car binding) table)
                  (cadr binding)))
          list)
    (make-array 3 :fill-pointer 3 :adjustable t
                  :initial-contents
                  (list (logior (ash (random (ash 1 31)) 1) 1) parent table))))

(defvar <closure> (vecenv nil nil))
(defvar <primitive> (vecenv nil nil))
(defvar <continuation> (vecenv nil nil))
(defvar *boot-env*)

(defvar <wrap> (vecenv nil (list (list 'length 1))))
(defvar <lookup-hook> (vecenv nil (list (list 'length 1))))
(defun wrap (operative) (record <wrap> operative))
(defun unwrap (wrap)
  (record-field wrap 0))
(defun lookup-hook (operative)
  (record <lookup-hook> operative))
(defun lookup-hook-operative (lookup-hook)
  (record-field lookup-hook 0))
(defun lookup-hook-p (object)
  (and (record-p object) (eq (record-descriptor object) <lookup-hook>)))

(defun vm-error (cont condition)
  (let ((handler-slot (lookup-local *boot-env* 'signal nil)))
    (if handler-slot
        (combine cont nil (unwrap handler-slot) (list condition))
        (error ".boot.signal not setup, panic: ~A" condition))))
(defun panic (condition)
  (error "Panic: ~A" condition))

(defun lookup (cont env x)
  (labels ((process (env-1)
             (let ((slot (lookup-local env-1 x '%%unbound)))
               (if (eq slot '%%unbound)
                   (if env-1 (process (parent env-1))
                       (vm-error cont (list 'unbound-key env x)))
                   (if (lookup-hook-p slot)
                       (combine cont env-1 (lookup-hook-operative slot) (list x))
                       (funcall cont slot))))))
    (process env)))

(defun lookup-local (env x default)
  (ecase (tag env)
    ((object)
     (ecase (id env)
       ((vecenv)
        (let ((p (position x (keyvec env) :test #'eq?)))
          (if p (value env p) default)))
       ((hashenv)
        (multiple-value-bind (value present-p) (gethash x (aref env 2))
          (if present-p value default)))))
    ((null) default)))

(defun keys (env)
  (ecase (tag env)
    ((object)
     (ecase (id env)
       ((vecenv) (map 'list #'identity (keyvec env)))
       ((hashenv)
        (loop for k being each hash-key of (aref env 2)
              collect k))))
    ((null) nil)))

(defun define! (env x y)
  (ecase (tag env)
    ((object)
     (ecase (id env)
       ((vecenv)
        (let ((p (position x (keyvec env) :test #'eq?)))
          (if p (setf (value env p) y)
              (progn
                (vector-push-extend x (keyvec env))
                (vector-push-extend y env)))))
       ((hashenv)
        (setf (gethash x (aref env 2)) y)))))
  y)

(defun mutate! (cont env x y)
  (macrolet ((mutate-place (place)
               `(if (lookup-hook-p ,place)
                    (lookup (lambda (setter)
                              (combine cont env setter (list x y)))
                            (lookup-hook-operative ,place) 'setter)
                    (funcall cont (setf ,place y)))))
    (ecase (tag env)
      ((object)
       (ecase (id env)
         ((vecenv)
          (let ((p (position x (keyvec env) :test #'eq?)))
            (if p (mutate-place (value env p))
                (mutate! cont (parent env) x y))))
         ((hashenv)
          (let ((present-p (nth-value 1 (gethash x (aref env 2)))))
            (if present-p
                (mutate-place (gethash x (aref env 2)))
                (mutate! cont (parent env) x y)))))))))

(defun mapeval (cont env forms results)
  (if (consp forms)
      (eval (lambda (result)
              (mapeval cont env (cdr forms) (cons result results)))
            env (car forms))
      (funcall cont (reverse results))))

(defun eval (cont env form)
  (case (tag form)
    ((cons)
     (eval (lambda (result)
             (combine cont env result (cdr form)))
           env (car form)))
    ((symbol) (lookup cont env form))
    (t (funcall cont form))))

(defun combine (cont env op args)
  (case (tag op)
    ((record)
     (if (eq (record-descriptor op) <wrap>)
         (mapeval (lambda (args)
                    (combine cont env (unwrap op) args))
                  env args nil)
         (vm-error cont (list 'unapplicable op))))
    ((object)
     (if (and (> (length op) 3) (functionp (value op 0)))
         (funcall (value op 0) op cont env args)
         (combine cont env (parent op) args)))
    (t (vm-error cont (list 'unapplicable op)))))

(defun vau (lexenv envf argsf expr)
  (vecenv <closure>
          (list
           (list 'code
                 (lambda (self cont env args &aux alist)
                   (let ((envf (value self 2))
                         (argsf (value self 3))
                         (expr (value self 4)))
                     (unless (eq envf '_) (push (list envf env) alist))
                     (unless (eq argsf '_) (push (list argsf args) alist))
                     (eval cont (vecenv (value self 1) alist) expr))))
           (list 'env lexenv)
           (list 'env-formal envf)
           (list 'args-formal argsf)
           (list 'expr expr)
           (list 'effect t))))

(defun cvau (&rest body)
  (let ((reg-symbols (make-hash-table)))
    (setf (gethash 0 reg-symbols) '%self
          (gethash 1 reg-symbols) '%env
          (gethash 2 reg-symbols) '%args)
    (labels ((reg-symbol (n)
               (declare (type fixnum n))
               (or (gethash n reg-symbols)
                   (setf (gethash n reg-symbols) (make-symbol (format nil "R~A" n)))))
             (process (body)
               (let* ((form (car body))
                      (dest (cadr form))
                      (rest (cddr form)))
                 (flet ((cont ()
                          (if (cdr body)
                              `(lambda (,(reg-symbol dest))
                                 ,(process (cdr body)))
                              `%cont))
                        (call-cont (value)
                          ;; Not strictly necessary, just to make
                          ;; emitted CL more readable and CL-debugger
                          ;; friendly
                          (if (cdr body)
                              (let ((rest (process (cdr body))))
                                (if (eq (car rest) 'let*)
                                    `(let* ((,(reg-symbol dest) ,value)
                                            ,@(cadr rest))
                                       ,@(cddr rest))
                                    `(let* ((,(reg-symbol dest) ,value))
                                       ,rest)))
                              `(funcall %cont ,value))))
                   (case (car form)
                     ((lit)
                      (call-cont `',(car rest)))
                     ((branch)
                      (let ((test (car rest))
                            (then (cadr rest))
                            (else (caddr rest)))
                        `(let ((%cont ,(cont)))
                           (if ,(reg-symbol test)
                               ,(process-begin then)
                               ,(process-begin else)))))
                     ((cvau)
                      (call-cont
                       `(vecenv <closure>
                                (list (list 'code
                                            (lambda (%self %cont %env %args)
                                              ,(process (cdr rest))))
                                      (list 'env ,(reg-symbol (car rest)))))))
                     ((eval combine lookup mutate! invoke-continuation! vm-error call/cc)
                      `(,(car form) ,(cont) ,@(mapcar #'reg-symbol rest)))
                     ((reg)
                      (assert (not (cdr body)))
                      (call-cont (reg-symbol dest)))
                     (t
                      (call-cont `(,(car form) ,@(mapcar #'reg-symbol rest))))))))
             (process-begin (form)
               (ecase (car form)
                 ((begin) (process (cdr form))))))
      (let ((sb-ext:*muffled-warnings* 'sb-int:simple-style-warning))
        (vecenv <closure>
                (list (list 'code (compile nil `(lambda (%self %cont %env %args)
                                                  (declare (optimize (debug 3)))
                                                  ,(process body))))))))))
(defun install-code! (vau cvau)
  (setf (value vau 0) (value cvau 0))
  t)

(defun make-prim (f &key env cont type effect)
  (let* ((lambda-name (intern (format nil "%~A" (symbol-name f))))
         (app `(apply #',f ,@(when cont `(cont)) ,@(when env `(env)) args))
         (app (if type `(if (typep (car args) ',type) ,app
                            (vm-error cont (list 'type-error (car args) ',type)))
                  app)))
    (vecenv <primitive>
            (list (list 'code (cl:eval `(labels ((,lambda-name (self cont env args)
                                                   (declare (ignore self ,@ (unless env `(env))))
                                                   ,(if cont app
                                                        `(funcall cont ,app))))
                                          #',lambda-name)))
                  (list 'name f)
                  (list 'effect effect)))))

(defun %if (cont env test then else)
  (eval (lambda (bool)
          (if bool (eval cont env then) (eval cont env else)))
        env test))
(defun %time (env form)
  (time (catch 'time
          (eval (lambda (result) (throw 'time result))
                env form))))
(defun %parent (x) (parent x))
(defun %id (x) (id x))
(defun call/cc (cont thunk)
  (combine cont nil (unwrap thunk) (list (vecenv <continuation> (list (list 'code cont))))))
(defun invoke-continuation! (cont new-cont value)
  (declare (ignore cont))
  (funcall (value new-cont 0) value))

(defvar *inspecting-object* nil)
(defun %inspect (x) (setq *inspecting-object* x))

(defun boot ()
  (let ((*boot-env*
          (hashenv nil `((vau0 ,(make-prim 'vau :env t))
                         (cvau ,(make-prim 'cvau))
                         #+nil (ins ,#'ins) #+nil (lit ,#'lit)
                         (<closure> ,<closure>)
                         (<primitive> ,<primitive>)
                         (<continuation> ,<continuation>)
                         (<lookup-hook> ,<lookup-hook>)
                         (<wrap> ,<wrap>)
                         (if ,(make-prim '%if :cont t :env t))
                         ,@ (mapcar (lambda (symbol)
                                      `(,(if (consp symbol) (car symbol) symbol)
                                        ,(wrap (apply #'make-prim (if (consp symbol) symbol (list symbol))))))
                                    '(define!
                                      tag cons (car :type cons) (cdr :type cons)
                                      > = < + - * /
                                      eq? vecenv hashenv keys
                                      (print :effect t) (break :effect t) (panic :effect t)
                                      record record-descriptor record-field
                                      lookup-hook-operative
                                      lookup-local (lookup :cont t)
                                      (mutate! :cont t :effect t)
                                      (eval :cont t :effect t) (combine :cont t :effect t)
                                      (call/cc :cont t :effect t)
                                      (invoke-continuation! :cont t :effect t)
                                      (install-code! :effect t)))
                         (lookup-hook? ,(wrap (make-prim 'lookup-hook-p)))
                         (parent ,(wrap (make-prim '%parent)))
                         (id ,(wrap (make-prim '%id)))
                         (time ,(make-prim '%time :env t))
                         (inspect ,(wrap (make-prim '%inspect)))
                         (nil nil)
                         (t t))))
        (*print-circle* t))
    (time (dolist (form (uiop:read-file-forms "boot.k"))
            (when (equal form '(**break**)) (return))
            (eval (lambda (result) (declare (ignore result))) *boot-env* form)))
    (handler-case
        (loop
          (format t "~&PK> ")
          (with-simple-restart
              (continue "Return to toplevel.")
              (eval #'print *boot-env* (read))))
      (end-of-file () (format t "~%Moriturus te saluto.")))))
