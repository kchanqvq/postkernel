(defpackage #:pk/hwsim
  (:use #:cl)
  (:shadow #:eval))
(in-package #:pk/hwsim)
(defstruct (wrap (:constructor wrap (operative))) (operative))
(defstruct residual (term))
(defun unwrap (x) (wrap-operative x))
(defun tag (x)
  (typecase x
    (cons 'cons)
    ((eql _) '_)
    (null 'null)
    (symbol 'symbol)
    (fixnum 'fixnum)
    (wrap 'wrap)
    (vector 'object)))

(defmacro id (x) `(aref ,x 0))
(defmacro parent (x) `(aref ,x 1))
(defmacro keyvec (x) `(aref ,x 2))
(defmacro value (x i) `(aref ,x (+ 3 ,i)))

(defun vecenv (parent list)
  (let ((s (length list)))
    (make-array (+ 3 s)
                :fill-pointer (+ 3 s)
                :adjustable t
                :initial-contents
                (list* 'vecenv parent
                       (make-array s :fill-pointer s
                                     :adjustable t
                                     :initial-contents (mapcar #'car list))
                       (mapcar #'cadr list)))))

(defvar <closure> (vecenv nil nil))
(defvar <primitive> (vecenv nil nil))

(defun lookup (env x)
  (ecase (tag env)
    ((object)
     (ecase (id env)
       ((vecenv)
        (let ((p (position x (keyvec env) :test 'equal)))
          (if p (value env p)
              (lookup (parent env) x))))))))

(defun bound? (env x)
  (ignore-errors (lookup env x) t))

(defun define! (env x y)
  (ecase (tag env)
    ((object)
     (ecase (id env)
       ((vecenv)
        (let ((p (position x (keyvec env) :test 'equal)))
          (if p (setf (value env p) y)
              (progn
                (vector-push-extend x (keyvec env))
                (vector-push-extend y env)
                y))))))))

(defun mutate! (env x y)
  (ecase (tag env)
    ((object)
     (ecase (id env)
       ((vecenv)
        (let ((p (position x (keyvec env) :test 'equal)))
          (if p (setf (value env p) y)
              (mutate! (parent env) x y))))))))

(defun eval (env form)
  (case (tag form)
    ((cons)
     (combine env (eval env (car form)) (cdr form)))
    ((symbol) (lookup env form))
    (t form)))

(defun combine (env op args)
  (ecase (tag op)
    ((wrap)
     (combine env (unwrap op) (mapcar (lambda (arg) (eval env arg)) args)))
    ((object)
     (funcall (value op 0) op env args))))

(defun vau (lexenv args)
  (assert (null (cdddr args)))
  (vecenv <closure>
          (list
           (list 'code
                 (lambda (self env args &aux alist)
                   (let ((envf (value self 2))
                         (argsf (value self 3))
                         (expr (value self 4)))
                     (unless (eq envf '_) (push (list envf env) alist))
                     (unless (eq argsf '_) (push (list argsf args) alist))
                     (eval (vecenv (value self 1) alist) expr))))
           (list 'env lexenv)
           (list 'env-formal (car args))
           (list 'args-formal (cadr args))
           (list 'expr (caddr args)))))

(defun adjust-env (lexenv dest)
  (unless (< dest (length (keyvec lexenv)))
    (let ((length (* 16 (ceiling (+ 1 dest) 16))))
      (adjust-array lexenv (+ length 3) :fill-pointer (+ dest 4))
      (adjust-array (keyvec lexenv) length :fill-pointer (+ dest 1)))))

(defun ins (lexenv args)
  (let ((dest (car args))
        (op (cadr args))
        (regs (cddr args)))
    (adjust-env lexenv dest)
    (setf (aref (keyvec lexenv) dest) nil)
    (setf (value lexenv dest)
          (apply op (mapcar (lambda (reg) (value lexenv reg)) regs)))))

(defun lit (lexenv args)
  (let ((dest (car args))
        (value (cadr args)))
    (adjust-env lexenv dest)
    (setf (aref (keyvec lexenv) dest) nil)
    (setf (value lexenv dest) value)))

(defun reg (lexenv args)
  (let ((reg (car args)))
    (value lexenv reg)))

(defun cvau (lexenv args)
  (declare (ignore lexenv))
  (let ((reg-symbols (make-hash-table))
        (fenv (car args))
        (farg (cadr args))
        (body (cddr args)))
    (setf (gethash 0 reg-symbols) fenv
          (gethash 1 reg-symbols) farg)
    (labels ((reg-symbol (n)
               (or (gethash n reg-symbols)
                   (setf (gethash n reg-symbols) (make-symbol (format nil "R~A" n)))))
             (process (body)
               `(let* ,(mapcar
                        (lambda (form)
                          (let ((dest (cadr form))
                                (rest (cddr form)))
                            `(,(reg-symbol dest)
                              ,(ecase (car form)
                                 ((ins)
                                  `(,(car rest) ,@(mapcar #'reg-symbol (cdr rest))))
                                 ((lit)
                                  `',(car rest))
                                 ((branch)
                                  (let ((test (car rest))
                                        (then (cadr rest))
                                        (else (caddr rest)))
                                    `(if ,(reg-symbol test)
                                         ,(process-begin then)
                                         ,(process-begin else))))))))
                        (butlast body))
                  ,(let ((form (car (last body))))
                     (ecase (car form)
                       ((reg) (reg-symbol (cadr form)))))))
             (process-begin (form)
               (ecase (car form)
                 ((begin) (process (cdr form))))))
      (vecenv <closure>
              (list (list 'code (compile nil `(lambda (self ,fenv ,farg) ,(process body)))))))))

(defun make-primop (f)
  (let ((lambda-name (intern (format nil "%~A" (symbol-name f)))))
    (vecenv <primitive>
            (list (list 'code (cl:eval `(labels ((,lambda-name (self env args)
                                                   (declare (ignore self))
                                                   (,f env args)))
                                          #',lambda-name)))
                  (list 'name f)))))

(defun make-primapp (f)
  (let ((lambda-name (intern (format nil "%~A" (symbol-name f)))))
    (wrap
     (vecenv <primitive>
             (list (list 'code (cl:eval `(labels ((,lambda-name (self env args)
                                                    (declare (ignore self env))
                                                    (apply #',f args)))
                                           #',lambda-name)))
                   (list 'name f))))))

(defun fexpr-if (env args)
  (if (eval env (car args))
      (eval env (cadr args))
      (eval env (caddr args))))

(defun fexpr-time (env args)
  (time (eval env (car args))))

(defun fexpr-parent (x) (parent x))

(defvar *inspecting-object* nil)

(defun fexpr-inspect (x) (setq *inspecting-object* x))

(defun boot ()
  (let ((env
          (vecenv nil `((vau0 ,(make-primop 'vau))
                        (cvau ,(make-primop 'cvau))
                        #+nil (ins ,#'ins) #+nil (lit ,#'lit)
                        (<closure> ,<closure>)
                        (<primitive> ,<primitive>)
                        (if ,(make-primop 'fexpr-if))
                        (eq? ,(make-primapp 'equal))
                        ,@ (mapcar (lambda (symbol) `(,symbol ,(make-primapp symbol)))
                                   '(eval combine define! mutate!
                                     tag cons car cdr wrap unwrap > = < + - * /
                                     vecenv print break lookup bound? error))
                        (parent ,(make-primapp 'fexpr-parent))
                        (time ,(make-primop 'fexpr-time))
                        (inspect ,(make-primapp 'fexpr-inspect))
                        (nil nil)
                        (t t))))
        (*print-circle* t))
    (dolist (form (uiop:read-file-forms "boot.k"))
      (when (equal form '(**break**)) (return))
      (eval env form))
    (handler-case
        (loop
          (format t "~&PK> ")
          (print (eval env (read))))
            (end-of-file () (format t "~%Moriturus te saluto.")))
    #+nil (prin1 (time (eval env '(fib 10))))))

(defun fib (x)
  (cond ((> x 1) (+ (fib (- x 1)) (fib (- x 2))))
        (t 1)))
#+nil (reify (m/eval (vector 'closure nil (lambda (_self _cont _env arg) arg)) *env* '(vau _ (x) (let ((y x)) y))))
#+nil (m/eval *halt* *env* `((vau1 _ (_ x) x) . ,(reflect 'x)))
#+nil (vau1 e0 (e args . body)
      (eval (list vau (eval (reflect e) (cons (eval e0 (list* vau1 e args body)) (reflect x))))))
