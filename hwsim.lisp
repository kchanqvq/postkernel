(defpackage #:pk/hwsim
  (:use #:cl))
(in-package #:pk/hwsim)
(defstruct (wrap (:constructor wrap (operative))) (operative))
(defun unwrap (x) (wrap-operative x))
(defun tag (x)
  (typecase x (cons 'cons) (symbol 'symbol) (fixnum 'fixnum) (wrap 'wrap) (vector 'object)))
(defun id (x) (aref x 0))
(defmacro parent (x) `(aref ,x 1))
(defmacro field (x i) `(aref ,x (+ 2 ,i)))
(defun k/envref (cont _env env x)
  (case (tag env)
    ((object)
     (case (id env)
       ((vecenv)
        (let ((p (position x (field env 0) :test 'equal)))
          (if p (k/combine nil nil cont (aref (field env 1) p))
              (k/envref cont _env (parent env) x))))))))
(defun k/diset (cont _env env x y)
  (case (tag env)
    ((object)
     (case (id env)
       ((vecenv)
        (let ((p (position x (field env 0) :test 'equal)))
          (if p (k/combine nil nil cont (setf (aref (field env 1) p) y))
              (progn
                (vector-push-extend x (field env 0))
                (vector-push-extend y (field env 1))
                (k/combine nil nil cont y)))))))))
(defun k/eval (cont env form)
  (break)
  (case (tag form)
    ((cons)
     (k/eval (vector 'closure cont (lambda (self _cont _env op) (apply #'k/combine (parent self) (field self 1) op (field self 2)))
                     env (cdr form))
             env (car form)))
    ((symbol) (k/envref cont nil env form))
    (t (k/combine nil nil cont form))))
(defun mapeval (cont env xs)
  (if (eq (tag xs) 'cons)
      (k/eval (vector 'closure cont
                      (lambda (self _cont _env y)
                        (mapeval (vector 'closure (parent self)
                                         (lambda (self _cont _env ys) (k/combine nil nil (parent self) (cons (field self 1) ys)))
                                         y)
                                 (field self 1) (field self 2)))
                      env (cdr xs))
              env (car xs))
      (k/combine nil nil cont xs)))
(defun k/combine (cont env op &rest args)
  (case (tag op)
    ((wrap)
     (mapeval (vector 'closure cont (lambda (self _cont _env args) (apply #'k/combine (parent self) (field self 1) (field self 2) args))
                      env (unwrap op))
              env args))
    ((object)
     (case (id op)
       ((closure) (apply (field op 0) op cont env args))
       (t (error "unapplicable object"))))
    (t (error "unapplicable tag"))))
(defun k/vau (cont env fenv formals body)
  (k/combine nil nil cont
             (vector 'closure nil
                     (lambda (self cont-1 env-1 &rest args)
                       (k/eval cont-1
                               (vector 'vecenv (field self 1)
                                       (apply #'vector (field self 2) (field self 3))
                                       (apply #'vector env-1 args))
                               (field self 4)))
                     env fenv formals body)))
(defun make-primtive (f)
  (vector 'closure nil (lambda (self cont env &rest args) (declare (ignore self)) (apply f cont env args))))
(defun make-pure (f)
  (wrap (vector 'closure nil (lambda (self cont env &rest args) (declare (ignore env self)) (k/combine nil nil cont (apply f args))))))
(defmacro make-env (&rest bindings)
  `(vector 'vecenv nil
           (make-array 8 :fill-pointer 8 :adjustable t :initial-contents ',(loop for k in bindings by #'cddr collect k))
           (make-array 8 :fill-pointer 8 :adjustable t :initial-contents (list ,@(loop for v in (cdr bindings) by #'cddr collect v)))))
(defvar *env*
  (make-env eval (wrap (make-primtive #'k/eval))
            combine (wrap (make-primtive #'k/combine))
            vau (make-primtive #'k/vau)
            cons (make-pure #'cons)
            car (make-pure #'car)
            cdr (make-pure #'cdr)
            wrap (make-pure #'wrap)
            diset (wrap (make-primtive #'k/diset))))
(defvar *halt* (vector 'closure nil (lambda (self _cont _env &rest args) (print args) (values))))
(k/eval *halt* *env*
        '(diset ((vau e () e)) ((vau _ (x) x) define)
          (vau e (x y) (diset e x (eval e y)))))
(k/eval *halt* *env*
        #+nil '(define the-environment (vau e () e))
        '(define x 1))
